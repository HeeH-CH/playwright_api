const express = require('express');
const { chromium, firefox, webkit } = require('playwright');
const { chromium: pwChromium } = require('playwright-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');

// Stealth í”ŒëŸ¬ê·¸ì¸ ì ìš©
pwChromium.use(StealthPlugin());

// ê¸°ë³¸ User-Agent ë° Stealth ì„¤ì •
const DEFAULT_USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36';
const sleep = (ms) => new Promise(r => setTimeout(r, ms));

const app = express();
app.use(express.json({ limit: '50mb' }));

// ì „ì—­ ë³€ìˆ˜
const sessions = new Map();
let sessionCounter = 0;

// ì„¸ì…˜ë³„ ë®¤í…ìŠ¤ ê´€ë¦¬
const sessionMutexes = new Map();

class Mutex {
  constructor() {
    this._locked = false;
    this._waiting = [];
  }

  async lock() {
    return new Promise((resolve) => {
      if (!this._locked) {
        this._locked = true;
        resolve();
      } else {
        this._waiting.push(resolve);
      }
    });
  }

  unlock() {
    if (this._waiting.length > 0) {
      const resolve = this._waiting.shift();
      resolve();
    } else {
      this._locked = false;
    }
  }

  isLocked() {
    return this._locked;
  }
}

// ì„¸ì…˜ë³„ ë®¤í…ìŠ¤ íšë“
function getSessionMutex(sessionId) {
  if (!sessionMutexes.has(sessionId)) {
    sessionMutexes.set(sessionId, new Mutex());
  }
  return sessionMutexes.get(sessionId);
}

// ë®¤í…ìŠ¤ë¡œ ë˜í•‘ëœ ì„¸ì…˜ ì‹¤í–‰ í•¨ìˆ˜
async function withSessionMutex(sessionId, operation) {
  const mutex = getSessionMutex(sessionId);
  
  console.log(`ğŸ”’ ì„¸ì…˜ ${sessionId} ë®¤í…ìŠ¤ ë½ ìš”ì²­ (ëŒ€ê¸°: ${mutex._waiting.length})`);
  
  await mutex.lock();
  
  try {
    console.log(`âœ… ì„¸ì…˜ ${sessionId} ë®¤í…ìŠ¤ ë½ íšë“`);
    const result = await operation();
    return result;
  } finally {
    mutex.unlock();
    console.log(`ğŸ”“ ì„¸ì…˜ ${sessionId} ë®¤í…ìŠ¤ ë½ í•´ì œ`);
  }
}

// ì„¸ì…˜ íƒ€ì„ì•„ì›ƒ ì„¤ì • (30ë¶„)
const SESSION_TIMEOUT = 30 * 60 * 1000; // 30ë¶„

// ìë™ ì •ë¦¬ í•¨ìˆ˜ (lastActivity ê¸°ë°˜)
function cleanupExpiredSessions() {
  const now = Date.now();
  
  for (const [sessionId, session] of sessions.entries()) {
    const lastActivityAge = now - session.lastActivity.getTime();
    
    if (lastActivityAge > SESSION_TIMEOUT) {
      console.log(`ğŸ§¹ ë¹„í™œì„± ì„¸ì…˜ ì •ë¦¬: ${sessionId} (ë§ˆì§€ë§‰ í™œë™: ${Math.round(lastActivityAge / 60000)}ë¶„ ì „)`);
      
      try {
        session.browser.close();
        sessions.delete(sessionId);
        // ë®¤í…ìŠ¤ë„ í•¨ê»˜ ì •ë¦¬
        sessionMutexes.delete(sessionId);
        console.log(`âœ… ì„¸ì…˜ ${sessionId} ì •ë¦¬ ì™„ë£Œ`);
      } catch (error) {
        console.error(`âŒ ì„¸ì…˜ ${sessionId} ì •ë¦¬ ì‹¤íŒ¨:`, error.message);
        sessions.delete(sessionId); // ë§µì—ì„œëŠ” ì œê±°
        sessionMutexes.delete(sessionId); // ë®¤í…ìŠ¤ë„ ì œê±°
      }
    }
  }
}

// 5ë¶„ë§ˆë‹¤ ë§Œë£Œëœ ì„¸ì…˜ ì •ë¦¬
setInterval(cleanupExpiredSessions, 5 * 60 * 1000);

// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
function generateSessionId() {
  return `session_${++sessionCounter}_${Date.now()}`;
}

function getSession(sessionId) {
  const session = sessions.get(sessionId);
  if (session) {
    session.lastActivity = new Date(); // í™œë™ ì‹œê°„ ì—…ë°ì´íŠ¸
  }
  return session;
}

function resolveLocator(page, { 
  selector, 
  frameSelector, 
  frameChain,
  // getBy methods
  getByRole,
  getByText,
  getByLabel,
  getByPlaceholder,
  getByAltText,
  getByTitle,
  getByTestId,
  // advanced methods
  filter,
  first,
  last,
  nth
}) {
  // Helper function to apply getBy methods to page/frame
  function applyGetByMethod(pageOrFrame) {
    if (getByRole) {
      const { role, ...options } = typeof getByRole === 'string' 
        ? { role: getByRole } 
        : getByRole;
      return pageOrFrame.getByRole(role, options);
    }
    if (getByText) {
      const options = typeof getByText === 'string' 
        ? { text: getByText } 
        : getByText;
      return pageOrFrame.getByText(options.text || options, {
        exact: options.exact,
        ignoreCase: options.ignoreCase
      });
    }
    if (getByLabel) {
      const options = typeof getByLabel === 'string' 
        ? { text: getByLabel } 
        : getByLabel;
      return pageOrFrame.getByLabel(options.text || options, {
        exact: options.exact,
        ignoreCase: options.ignoreCase
      });
    }
    if (getByPlaceholder) {
      const options = typeof getByPlaceholder === 'string' 
        ? { text: getByPlaceholder } 
        : getByPlaceholder;
      return pageOrFrame.getByPlaceholder(options.text || options, {
        exact: options.exact,
        ignoreCase: options.ignoreCase
      });
    }
    if (getByAltText) {
      const options = typeof getByAltText === 'string' 
        ? { text: getByAltText } 
        : getByAltText;
      return pageOrFrame.getByAltText(options.text || options, {
        exact: options.exact,
        ignoreCase: options.ignoreCase
      });
    }
    if (getByTitle) {
      const options = typeof getByTitle === 'string' 
        ? { text: getByTitle } 
        : getByTitle;
      return pageOrFrame.getByTitle(options.text || options, {
        exact: options.exact,
        ignoreCase: options.ignoreCase
      });
    }
    if (getByTestId) {
      return pageOrFrame.getByTestId(getByTestId);
    }
    
    // fallback to selector
    return pageOrFrame.locator(selector);
  }

  // A) frameSelector: ë‹¨ì¼ í”„ë ˆì„ ì„ íƒì
  if (frameSelector) {
    const frameLocator = page.frameLocator(frameSelector);
    const locator = applyGetByMethod(frameLocator);
    return applyAdvancedMethods(locator);
  }

  // B) frameChain: ì¤‘ì²© í”„ë ˆì„ ë°°ì—´ ì§€ì›
  if (Array.isArray(frameChain) && frameChain.length > 0) {
    let fl = page;
    for (const fs of frameChain) {
      fl = fl.frameLocator(fs);
    }
    const locator = applyGetByMethod(fl);
    return applyAdvancedMethods(locator);
  }

  // C) '>>' ë¬¸ë²• ì§€ì› (frameA >> frameB >> .target)
  if (typeof selector === 'string' && selector.includes('>>')) {
    const parts = selector.split(/\s*>>\s+/).filter(p => p.trim());
    let fl = page;
    while (parts.length > 1) {
      const fs = parts.shift();
      fl = fl.frameLocator(fs);
    }
    const target = parts[0];
    const locator = fl.locator(target);
    return applyAdvancedMethods(locator);
  }

  // D) getBy methods ë˜ëŠ” ê¸°ë³¸ selector
  const locator = applyGetByMethod(page);
  return applyAdvancedMethods(locator);
  
  // Helper function to apply advanced methods (filter, first, last, nth)
  function applyAdvancedMethods(locator) {
    // Apply filter method
    if (filter) {
      if (filter.hasText !== undefined) {
        locator = locator.filter({ hasText: filter.hasText });
      }
      if (filter.has !== undefined) {
        locator = locator.filter({ has: page.locator(filter.has) });
      }
      if (filter.hasNot !== undefined) {
        locator = locator.filter({ hasNot: page.locator(filter.hasNot) });
      }
    }
    
    // Apply positional methods
    if (first === true) {
      locator = locator.first();
    } else if (last === true) {
      locator = locator.last();
    } else if (typeof nth === 'number') {
      locator = locator.nth(nth);
    }
    
    return locator;
  }
}

// ì„¸ì…˜ ì—°ì¥
app.post('/session/extend', async (req, res) => {
  try {
    const { sessionId } = req.body;
    const session = sessions.get(sessionId);
    
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    session.lastActivity = new Date();
    
    res.json({ 
      success: true,
      sessionId: sessionId,
      extendedAt: session.lastActivity,
      message: 'Session extended successfully'
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// CORS ì„¤ì •
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
});

// ìƒíƒœ í™•ì¸
app.get('/health', (req, res) => {
  res.json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    activeSessions: sessions.size,
    uptime: process.uptime()
  });
});

// í™œì„± ì„¸ì…˜ ëª©ë¡ (ê°œì„ ëœ ë²„ì „)
app.get('/sessions', (req, res) => {
  const now = new Date();
  const sessionList = Array.from(sessions.entries()).map(([id, session]) => {
    const ageMinutes = Math.round((now - session.createdAt) / 60000);
    const inactiveMinutes = Math.round((now - session.lastActivity) / 60000);
    const mutex = sessionMutexes.get(id);
    return {
      sessionId: id,
      url: session.page ? session.page.url() : 'unknown',
      createdAt: session.createdAt,
      lastActivity: session.lastActivity,
      ageMinutes: ageMinutes,
      inactiveMinutes: inactiveMinutes,
      status: inactiveMinutes > 30 ? 'expired' : 'active',
      mutexStatus: {
        locked: mutex ? mutex.isLocked() : false,
        waitingCount: mutex ? mutex._waiting.length : 0
      }
    };
  });
  
  res.json({ 
    sessions: sessionList,
    count: sessionList.length,
    activeCount: sessionList.filter(s => s.status === 'active').length,
    expiredCount: sessionList.filter(s => s.status === 'expired').length,
    timeoutMinutes: SESSION_TIMEOUT / 60000,
    mutexCount: sessionMutexes.size
  });
});

// ëª¨ë“  ì„¸ì…˜ ê°•ì œ ì¢…ë£Œ
app.post('/sessions/cleanup', async (req, res) => {
  const closedSessions = [];
  const errors = [];
  
  for (const [sessionId, session] of sessions.entries()) {
    try {
      await session.browser.close();
      sessions.delete(sessionId);
      sessionMutexes.delete(sessionId); // ë®¤í…ìŠ¤ë„ í•¨ê»˜ ì •ë¦¬
      closedSessions.push(sessionId);
      console.log(`ğŸ§¹ ê°•ì œ ì¢…ë£Œ: ${sessionId}`);
    } catch (error) {
      errors.push({ sessionId, error: error.message });
      sessions.delete(sessionId); // ë§µì—ì„œëŠ” ì œê±°
      sessionMutexes.delete(sessionId); // ë®¤í…ìŠ¤ë„ ì œê±°
    }
  }
  
  res.json({
    success: true,
    closedSessions: closedSessions,
    errors: errors,
    message: `${closedSessions.length}ê°œ ì„¸ì…˜ ì¢…ë£Œ ì™„ë£Œ`
  });
});

// 1. ë¸Œë¼ìš°ì € ì‹œì‘
app.post('/browser/launch', async (req, res) => {
  try {
    const { 
      browser = 'chromium', 
      headless = true, 
      viewport = { width: 1920, height: 1080 },
      userAgent,
      locale = 'ko-KR',
      timezone = 'Asia/Seoul'
    } = req.body;

    console.log(`ğŸš€ ë¸Œë¼ìš°ì € ì‹œì‘: ${browser}, headless: ${headless}`);

    let browserInstance;
    const launchOptions = {
      headless,
      args: [
        '--no-sandbox',
        '--disable-dev-shm-usage',
        '--disable-web-security',
        '--disable-features=VizDisplayCompositor'
      ]
    };

    // ë¸Œë¼ìš°ì € íƒ€ì…ë³„ ì‹¤í–‰
    switch (browser.toLowerCase()) {
      case 'firefox':
        browserInstance = await firefox.launch(launchOptions);
        break;
      case 'webkit':
        browserInstance = await webkit.launch(launchOptions);
        break;
      default:
        // Stealth Chromium ì‚¬ìš© (íƒì§€ ìš°íšŒ ê¸°ëŠ¥ í¬í•¨)
        launchOptions.args = [
          '--no-sandbox',
          '--disable-dev-shm-usage',
          '--disable-web-security',
          '--disable-features=VizDisplayCompositor',
          '--disable-blink-features=AutomationControlled',
          '--disable-features=IsolateOrigins,site-per-process'
        ];
        browserInstance = await pwChromium.launch(launchOptions);
    }

    // Stealth ì»¨í…ìŠ¤íŠ¸ ì„¤ì • (ìš°íšŒ ê¸°ëŠ¥ ê°•í™”)
    const contextOptions = {
      viewport: viewport || { width: 1366, height: 768 },
      userAgent: userAgent || DEFAULT_USER_AGENT,
      locale: locale || 'ko-KR',
      timezoneId: timezone || 'Asia/Seoul',
      geolocation: { longitude: 126.9780, latitude: 37.5665 },
      permissions: ['geolocation'],
      colorScheme: 'light',
      javaScriptEnabled: true,
      extraHTTPHeaders: {
        'Accept-Language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7'
      }
    };

    const context = await browserInstance.newContext(contextOptions);

    // ìš°íšŒ ê¸°ëŠ¥ ê°•í™” ìŠ¤í¬ë¦½íŠ¸ ì¶”ê°€
    await context.addInitScript(() => {
      // webdriver í”ì  ìµœì†Œí™”
      Object.defineProperty(navigator, 'pdfViewerEnabled', { get: () => true });
      // í”ŒëŸ¬ê·¸ì¸ ê°œìˆ˜ ì±„ìš°ê¸°
      Object.defineProperty(navigator, 'plugins', { get: () => [{}, {}, {}] });
      // ì¶”ê°€ webdriver ì†ì„± ìˆ¨ê¸°ê¸°
      Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
      // Chrome runtime ì†ì„± ë§ˆìŠ¤í‚¹
      window.chrome = window.chrome || { runtime: {} };
      // Permission API ë§ˆìŠ¤í‚¹
      const originalQuery = window.navigator.permissions.query;
      window.navigator.permissions.query = (parameters) => (
        parameters.name === 'notifications' ?
          Promise.resolve({ state: Notification.permission }) :
          originalQuery(parameters)
      );
    });

    // ìƒˆ í˜ì´ì§€ ìƒì„±
    const page = await context.newPage();
    const sessionId = generateSessionId();

    // ì„¸ì…˜ ì €ì¥
// ì„¸ì…˜ ìƒì„±ì‹œ lastActivity ì¶”ê°€
    sessions.set(sessionId, {
      browser: browserInstance,
      context,
      page,
      createdAt: new Date(),
      lastActivity: new Date() // ë§ˆì§€ë§‰ í™œë™ ì‹œê°„ ì¶”ê°€
    });

    console.log(`âœ… ë¸Œë¼ìš°ì € ì‹œì‘ ì™„ë£Œ: ${sessionId}`);

    res.json({ 
      success: true, 
      sessionId,
      browser: browser,
      headless: headless,
      message: `${browser} browser launched successfully`
    });

  } catch (error) {
    console.error('âŒ ë¸Œë¼ìš°ì € ì‹œì‘ ì‹¤íŒ¨:', error);
    res.status(500).json({ 
      success: false,
      error: error.message 
    });
  }
});

// 2. ë¸Œë¼ìš°ì € ì¢…ë£Œ
app.post('/browser/close', async (req, res) => {
  try {
    const { sessionId } = req.body;
    const session = getSession(sessionId);
    
    if (!session) {
      return res.status(404).json({ 
        success: false,
        error: 'Session not found' 
      });
    }

    console.log(`ğŸ”„ ë¸Œë¼ìš°ì € ì¢…ë£Œ: ${sessionId}`);

    await session.browser.close();
    sessions.delete(sessionId);
    // ë®¤í…ìŠ¤ë„ í•¨ê»˜ ì •ë¦¬
    sessionMutexes.delete(sessionId);
    
    console.log(`âœ… ë¸Œë¼ìš°ì € ì¢…ë£Œ ì™„ë£Œ: ${sessionId}`);
    
    res.json({ 
      success: true, 
      message: 'Browser closed successfully' 
    });

  } catch (error) {
    console.error('âŒ ë¸Œë¼ìš°ì € ì¢…ë£Œ ì‹¤íŒ¨:', error);
    res.status(500).json({ 
      success: false,
      error: error.message 
    });
  }
});

// 3. í˜ì´ì§€ ì´ë™
app.post('/page/goto', async (req, res) => {
  try {
    const { sessionId, url, options = {} } = req.body;
    
    if (!sessionId) {
      return res.status(400).json({ 
        success: false,
        error: 'sessionId is required' 
      });
    }

    const result = await withSessionMutex(sessionId, async () => {
      const session = getSession(sessionId);
      
      if (!session) {
        throw new Error('Session not found');
      }

      console.log(`ğŸŒ í˜ì´ì§€ ì´ë™: ${url}`);

      // ë„¤ì´ë²„ì™€ ê°™ì€ ë¬´ê±°ìš´ ì‚¬ì´íŠ¸ë¥¼ ìœ„í•œ ê°œì„ ëœ í˜ì´ì§€ ë¡œë“œ ë¡œì§
      const defaultOptions = {
        waitUntil: 'domcontentloaded', // networkidleë³´ë‹¤ ì•ˆì •ì 
        timeout: 60000, // 30ì´ˆ -> 60ì´ˆë¡œ ì¦ê°€
        ...options
      };

      // ì¬ì‹œë„ ë¡œì§ (ìµœëŒ€ 2íšŒ)
      let retryCount = 0;
      const maxRetries = 2;
      
      while (retryCount <= maxRetries) {
        try {
          // ì‚¬ëŒì²˜ëŸ¼ ë³´ì´ëŠ” ëœë¤ ë”œë ˆì´ (500-1300ms)
          await sleep(500 + Math.random() * 800);
          await session.page.goto(url, defaultOptions);
          // í˜ì´ì§€ ë¡œë“œ í›„ ëœë¤ ë§ˆìš°ìŠ¤ ì´ë™
          await sleep(200 + Math.random() * 400);
          await session.page.mouse.move(
            200 + Math.random() * 300,
            300 + Math.random() * 200,
            { steps: 12 }
          );
          break; // ì„±ê³µí•˜ë©´ ë£¨í”„ íƒˆì¶œ
        } catch (error) {
          retryCount++;
          console.log(`âš ï¸ í˜ì´ì§€ ë¡œë“œ ì‹œë„ ${retryCount}/${maxRetries + 1} ì‹¤íŒ¨: ${error.message}`);
          
          if (retryCount > maxRetries) {
            // ìµœì¢… ì‹¤íŒ¨ ì‹œ domcontentloadedë¡œ í•œ ë²ˆ ë” ì‹œë„
            console.log('ğŸ”„ domcontentloadedë¡œ ìµœì¢… ì‹œë„...');
            await session.page.goto(url, {
              ...defaultOptions,
              waitUntil: 'domcontentloaded',
              timeout: 45000
            });
            break;
          }
          
          // ì¬ì‹œë„ ì „ ì ê¹ ëŒ€ê¸°
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      }

      const pageInfo = {
        url: session.page.url(),
        title: await session.page.title()
      };

      console.log(`âœ… í˜ì´ì§€ ë¡œë“œ ì™„ë£Œ: ${pageInfo.title}`);

      return pageInfo;
    });

    res.json({ 
      success: true, 
      ...result
    });

  } catch (error) {
    console.error('âŒ í˜ì´ì§€ ì´ë™ ì‹¤íŒ¨:', error);
    res.status(500).json({ 
      success: false,
      error: error.message 
    });
  }
});

// 4. í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨
app.post('/page/reload', async (req, res) => {
  try {
    const { sessionId } = req.body;
    const session = getSession(sessionId);
    
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    await session.page.reload({ waitUntil: 'networkidle' });
    
    res.json({ 
      success: true,
      url: session.page.url(),
      title: await session.page.title()
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 5. HTML ì½˜í…ì¸  ê°€ì ¸ì˜¤ê¸°
app.post('/page/content', async (req, res) => {
  try {
    const { sessionId } = req.body;
    const session = getSession(sessionId);
    
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    console.log('ğŸ“„ HTML ì½˜í…ì¸  ì¶”ì¶œ ì¤‘...');

    const content = await session.page.content();
    
    console.log(`âœ… HTML ì¶”ì¶œ ì™„ë£Œ: ${content.length} ë¬¸ì`);

    res.json({ 
      success: true, 
      content: content,
      length: content.length
    });

  } catch (error) {
    console.error('âŒ HTML ì¶”ì¶œ ì‹¤íŒ¨:', error);
    res.status(500).json({ error: error.message });
  }
});

// 6. í˜ì´ì§€ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
app.post('/page/info', async (req, res) => {
  try {
    const { sessionId } = req.body;
    const session = getSession(sessionId);
    
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    const info = {
      url: session.page.url(),
      title: await session.page.title(),
      timestamp: new Date().toISOString()
    };

    res.json({ success: true, info });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 7. JavaScript ì‹¤í–‰ (ë¸Œë¼ìš°ì € ì»¨í…ìŠ¤íŠ¸ì—ì„œ)
app.post('/page/evaluate', async (req, res) => {
  try {
    const { sessionId, script } = req.body;
    const session = getSession(sessionId);
    
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    console.log('ğŸ”§ JavaScript ì‹¤í–‰ ì¤‘...');

    // ë¸Œë¼ìš°ì € ì»¨í…ìŠ¤íŠ¸ì—ì„œ ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
    const result = await session.page.evaluate((scriptToExecute) => {
      return eval(scriptToExecute);
    }, script);

    console.log('âœ… JavaScript ì‹¤í–‰ ì™„ë£Œ');

    res.json({ success: true, result });

  } catch (error) {
    console.error('âŒ JavaScript ì‹¤í–‰ ì‹¤íŒ¨:', error);
    res.status(500).json({ error: error.message });
  }
});

// 8. ìš”ì†Œ í´ë¦­
app.post('/page/click', async (req, res) => {
  try {
    const { 
      sessionId, 
      selector, 
      frameSelector, 
      frameChain, 
      options = {},
      getByRole,
      getByText,
      getByLabel,
      getByPlaceholder,
      getByAltText,
      getByTitle,
      getByTestId,
      // advanced methods
      filter,
      first,
      last,
      nth
    } = req.body;
    
    if (!sessionId) {
      return res.status(400).json({ error: 'sessionId is required' });
    }

    await withSessionMutex(sessionId, async () => {
      const session = getSession(sessionId);
      
      if (!session) {
        throw new Error('Session not found');
      }

      console.log(`ğŸ–±ï¸ í´ë¦­: ${selector || getByRole || getByText || getByLabel || getByPlaceholder || getByAltText || getByTitle || getByTestId}`);

      const locator = resolveLocator(session.page, { 
        selector, 
        frameSelector, 
        frameChain,
        getByRole,
        getByText,
        getByLabel,
        getByPlaceholder,
        getByAltText,
        getByTitle,
        getByTestId,
        filter,
        first,
        last,
        nth
      });
      
      // ì‚¬ëŒì²˜ëŸ¼ ë³´ì´ëŠ” í´ë¦­ ì „ ëœë¤ ë”œë ˆì´
      await sleep(100 + Math.random() * 300);

      await locator.click({
        timeout: 15000,
        ...options
      });

      // í´ë¦­ í›„ ì§§ì€ ëŒ€ê¸°
      await sleep(50 + Math.random() * 150);

      console.log(`âœ… í´ë¦­ ì™„ë£Œ: ${selector}`);
    });

    res.json({ success: true });

  } catch (error) {
    console.error('âŒ í´ë¦­ ì‹¤íŒ¨:', error);
    res.status(500).json({ error: error.message });
  }
});

// 9. í…ìŠ¤íŠ¸ ì…ë ¥
app.post('/page/fill', async (req, res) => {
  try {
    const { 
      sessionId, 
      selector, 
      text, 
      frameSelector, 
      frameChain, 
      options = {},
      getByRole,
      getByText,
      getByLabel,
      getByPlaceholder,
      getByAltText,
      getByTitle,
      getByTestId,
      // advanced methods
      filter,
      first,
      last,
      nth
    } = req.body;
    
    if (!sessionId) {
      return res.status(400).json({ error: 'sessionId is required' });
    }

    await withSessionMutex(sessionId, async () => {
      const session = getSession(sessionId);
      
      if (!session) {
        throw new Error('Session not found');
      }

      console.log(`âŒ¨ï¸ í…ìŠ¤íŠ¸ ì…ë ¥: ${selector || getByRole || getByText || getByLabel || getByPlaceholder || getByAltText || getByTitle || getByTestId} -> "${text}"`);

      const locator = resolveLocator(session.page, { 
        selector, 
        frameSelector, 
        frameChain,
        getByRole,
        getByText,
        getByLabel,
        getByPlaceholder,
        getByAltText,
        getByTitle,
        getByTestId,
        filter,
        first,
        last,
        nth
      });

      // ì‚¬ëŒì²˜ëŸ¼ ë³´ì´ëŠ” ì…ë ¥ ì „ ëœë¤ ë”œë ˆì´
      await sleep(100 + Math.random() * 300);

      try {
        await locator.fill(text, {
          timeout: 15000,
          ...options
        });
      } catch {
        console.log(`ğŸ”„ ëŒ€ì²´ ì…ë ¥ ë°©ì‹ ì‚¬ìš©: ${selector}`);
        await locator.click({ timeout: 15000 });
        await session.page.keyboard.down('Control');
        await session.page.keyboard.press('KeyA');
        await session.page.keyboard.up('Control');
        // ì‚¬ëŒì²˜ëŸ¼ ë³´ì´ëŠ” íƒ€ì´í•‘ ë”œë ˆì´ (60-90ms)
        await session.page.keyboard.type(text, { delay: 60 + Math.random() * 30 });
      }

      // ì…ë ¥ í›„ ì§§ì€ ëŒ€ê¸°
      await sleep(50 + Math.random() * 150);

      console.log(`âœ… í…ìŠ¤íŠ¸ ì…ë ¥ ì™„ë£Œ: ${selector}`);
    });

    res.json({ success: true });

  } catch (error) {
    console.error('âŒ í…ìŠ¤íŠ¸ ì…ë ¥ ì‹¤íŒ¨:', error);
    res.status(500).json({ error: error.message });
  }
});

// 10. ìš”ì†Œ ëŒ€ê¸°
app.post('/page/waitFor', async (req, res) => {
  try {
    const { 
      sessionId, 
      selector, 
      frameSelector, 
      frameChain, 
      options = {},
      getByRole,
      getByText,
      getByLabel,
      getByPlaceholder,
      getByAltText,
      getByTitle,
      getByTestId,
      // advanced methods
      filter,
      first,
      last,
      nth
    } = req.body;
    
    if (!sessionId) {
      return res.status(400).json({ error: 'sessionId is required' });
    }

    await withSessionMutex(sessionId, async () => {
      const session = getSession(sessionId);
      
      if (!session) {
        throw new Error('Session not found');
      }

      console.log(`â³ ìš”ì†Œ ëŒ€ê¸°: ${selector || getByRole || getByText || getByLabel || getByPlaceholder || getByAltText || getByTitle || getByTestId}`);

      const locator = resolveLocator(session.page, { 
        selector, 
        frameSelector, 
        frameChain,
        getByRole,
        getByText,
        getByLabel,
        getByPlaceholder,
        getByAltText,
        getByTitle,
        getByTestId,
        filter,
        first,
        last,
        nth
      });
      
      await locator.waitFor({
        timeout: 30000,
        ...options
      });

      console.log(`âœ… ìš”ì†Œ ëŒ€ê¸° ì™„ë£Œ: ${selector}`);
    });

    res.json({ success: true });

  } catch (error) {
    console.error('âŒ ìš”ì†Œ ëŒ€ê¸° ì‹¤íŒ¨:', error);
    res.status(500).json({ error: error.message });
  }
});

// 11. ìŠ¤í¬ë¦°ìƒ·
app.post('/page/screenshot', async (req, res) => {
  try {
    const { sessionId, options = {} } = req.body;
    const session = getSession(sessionId);
    
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    console.log('ğŸ“¸ ìŠ¤í¬ë¦°ìƒ· ìº¡ì²˜ ì¤‘...');

    const screenshot = await session.page.screenshot({
      type: 'png',
      encoding: 'base64',
      fullPage: false,
      ...options
    });

    console.log('âœ… ìŠ¤í¬ë¦°ìƒ· ì™„ë£Œ');

    res.json({ 
      success: true, 
      screenshot: screenshot 
    });

  } catch (error) {
    console.error('âŒ ìŠ¤í¬ë¦°ìƒ· ì‹¤íŒ¨:', error);
    res.status(500).json({ error: error.message });
  }
});

// 12. í…ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°
app.post('/page/getText', async (req, res) => {
  try {
    const { sessionId, selector } = req.body;
    const session = getSession(sessionId);
    
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    const text = await session.page.textContent(selector);
    
    res.json({ 
      success: true, 
      text: text 
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 13. ì†ì„± ê°€ì ¸ì˜¤ê¸°
app.post('/page/getAttribute', async (req, res) => {
  try {
    const { sessionId, selector, attribute } = req.body;
    const session = getSession(sessionId);
    
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    const value = await session.page.getAttribute(selector, attribute);
    
    res.json({ 
      success: true, 
      value: value 
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 14. í‚¤ë³´ë“œ ì…ë ¥
app.post('/page/keyboard', async (req, res) => {
  try {
    const { sessionId, action, key, text, delay = 50, repeat = 1 } = req.body;
    const session = getSession(sessionId);
    
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    // ì‚¬ëŒì²˜ëŸ¼ ë³´ì´ëŠ” í‚¤ë³´ë“œ ì „ ëœë¤ ë”œë ˆì´
    await sleep(50 + Math.random() * 100);

    switch (action) {
      case 'press':
        for (let i = 0; i < repeat; i++) {
          await session.page.keyboard.press(key);
          if (repeat > 1 && delay > 0) {
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
        break;
      case 'type':
        // ì‚¬ëŒì²˜ëŸ¼ ë³´ì´ëŠ” íƒ€ì´í•‘ ë”œë ˆì´ ê°•í™” (60-150ms)
        const humanDelay = Math.max(delay, 60 + Math.random() * 90);
        await session.page.keyboard.type(text, { delay: humanDelay });
        break;
      case 'insertText':
        // ê°œí–‰ ë¬¸ìë¥¼ ì‹¤ì œ Enter í‚¤ë¡œ ì²˜ë¦¬í•˜ê³  ìœ ë‹ˆì½”ë“œ ì•ˆì „ ì…ë ¥
        const lines = text.replace(/\r\n/g, '\n').split('\n');
        for (let i = 0; i < lines.length; i++) {
          if (lines[i]) {
            // ìœ ë‹ˆì½”ë“œ ì•ˆì „ ì…ë ¥ (ì´ëª¨ì§€ í¬í•¨) + ì‚¬ëŒì²˜ëŸ¼ ë³´ì´ëŠ” ë”œë ˆì´
            const humanInsertDelay = Math.max(delay, 60 + Math.random() * 90);
            await session.page.keyboard.type(lines[i], { delay: humanInsertDelay });
          }
          if (i < lines.length - 1) {
            await session.page.keyboard.press('Enter');
            await sleep(50 + Math.random() * 100); // ê°œí–‰ í›„ ì§§ì€ ëŒ€ê¸°
          }
        }
        break;
      case 'down':
        await session.page.keyboard.down(key);
        break;
      case 'up':
        await session.page.keyboard.up(key);
        break;
      default:
        return res.status(400).json({ error: 'Invalid keyboard action' });
    }

    res.json({ success: true });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 15. ìŠ¤í¬ë¡¤
app.post('/page/scroll', async (req, res) => {
  try {
    const { sessionId, x = 0, y = 0 } = req.body;
    const session = getSession(sessionId);
    
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    await session.page.evaluate(({ x, y }) => {
      window.scrollBy(x, y);
    }, { x, y });

    res.json({ success: true });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 16. íŒŒì¼ ì—…ë¡œë“œ (ì¼ë°˜)
app.post('/page/uploadFile', async (req, res) => {
  try {
    const { 
      sessionId, 
      selector, 
      frameSelector, 
      frameChain,
      files,
      options = {},
      getByRole,
      getByText,
      getByLabel,
      getByPlaceholder,
      getByAltText,
      getByTitle,
      getByTestId,
      // advanced methods
      filter,
      first,
      last,
      nth
    } = req.body;
    const session = getSession(sessionId);
    
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    if (!files || !Array.isArray(files) || files.length === 0) {
      return res.status(400).json({ error: 'files array is required' });
    }

    console.log(`ğŸ“ íŒŒì¼ ì—…ë¡œë“œ ì‹œì‘: ${files.length}ê°œ íŒŒì¼`);

    // íŒŒì¼ ë°ì´í„° ì²˜ë¦¬
    const fileInputs = files.map(file => {
      if (file.base64) {
        // Base64 ë°ì´í„° ì²˜ë¦¬
        const base64Data = file.base64.replace(/^data:[^;]+;base64,/, '');
        return {
          name: file.name || 'file',
          mimeType: file.mimeType || 'application/octet-stream',
          buffer: Buffer.from(base64Data, 'base64')
        };
      } else if (file.path) {
        // ë¡œì»¬ íŒŒì¼ ê²½ë¡œ
        return file.path;
      } else if (file.buffer && file.name) {
        // ì§ì ‘ buffer ì œê³µ
        return {
          name: file.name,
          mimeType: file.mimeType || 'application/octet-stream',
          buffer: Buffer.from(file.buffer)
        };
      } else {
        throw new Error('Invalid file format: requires base64, path, or buffer+name');
      }
    });

    // íŒŒì¼ input ìš”ì†Œì— íŒŒì¼ ì„¤ì •
    if (selector || getByRole || getByText || getByLabel || getByPlaceholder || getByAltText || getByTitle || getByTestId) {
      // íŠ¹ì • selector ë˜ëŠ” getBy ë©”ì†Œë“œ ì‚¬ìš©
      const locator = resolveLocator(session.page, { 
        selector, 
        frameSelector, 
        frameChain,
        getByRole,
        getByText,
        getByLabel,
        getByPlaceholder,
        getByAltText,
        getByTitle,
        getByTestId,
        filter,
        first,
        last,
        nth
      });
      
      if (files.length === 1) {
        await locator.setInputFiles(fileInputs[0], options);
      } else {
        await locator.setInputFiles(fileInputs, options);
      }
    } else {
      // selectorê°€ ì—†ìœ¼ë©´ í˜ì´ì§€ì˜ ì²« ë²ˆì§¸ file input ì°¾ê¸°
      const fileInput = session.page.locator('input[type="file"]').first();
      
      if (files.length === 1) {
        await fileInput.setInputFiles(fileInputs[0], options);
      } else {
        await fileInput.setInputFiles(fileInputs, options);
      }
    }

    console.log('âœ… íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ');

    res.json({ 
      success: true,
      uploadedFiles: files.map(f => f.name || f.path),
      count: files.length
    });

  } catch (error) {
    console.error('âŒ íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨:', error);
    res.status(500).json({ error: error.message });
  }
});





// ì—ëŸ¬ í•¸ë“¤ë§
app.use((error, req, res, next) => {
  console.error('ì„œë²„ ì˜¤ë¥˜:', error);
  res.status(500).json({ 
    success: false,
    error: 'Internal server error',
    message: error.message
  });
});

// ì„œë²„ ì‹œì‘
const PORT = process.env.PORT || 3001;
app.listen(PORT, '0.0.0.0', () => {
  console.log('ğŸš€ Playwright HTTP API Server Started!');
  console.log(`ğŸ“¡ Server: http://localhost:${PORT}`);
  console.log('ğŸ“‹ Available endpoints:');
  console.log('  GET  /health              - ì„œë²„ ìƒíƒœ');
  console.log('  GET  /sessions            - í™œì„± ì„¸ì…˜ ëª©ë¡');
  console.log('  POST /browser/launch      - ë¸Œë¼ìš°ì € ì‹œì‘');
  console.log('  POST /browser/close       - ë¸Œë¼ìš°ì € ì¢…ë£Œ');
  console.log('  POST /page/goto           - í˜ì´ì§€ ì´ë™');
  console.log('  POST /page/content        - HTML ê°€ì ¸ì˜¤ê¸°');
  console.log('  POST /page/info           - í˜ì´ì§€ ì •ë³´');
  console.log('  POST /page/evaluate       - JavaScript ì‹¤í–‰');
  console.log('  POST /page/click          - ìš”ì†Œ í´ë¦­');
  console.log('  POST /page/fill           - í…ìŠ¤íŠ¸ ì…ë ¥');
  console.log('  POST /page/screenshot     - ìŠ¤í¬ë¦°ìƒ·');
  console.log('  POST /page/uploadFile     - íŒŒì¼ ì—…ë¡œë“œ');
  console.log('');
  console.log('âœ¨ ì¤€ë¹„ ì™„ë£Œ! í¬ë¡¤ë§ì„ ì‹œì‘í•˜ì„¸ìš”.');
});

// í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ì‹œ ëª¨ë“  ë¸Œë¼ìš°ì € ì •ë¦¬
process.on('SIGINT', async () => {
  console.log('\nğŸ”„ ì„œë²„ ì¢…ë£Œ ì¤‘...');
  
  for (const [sessionId, session] of sessions.entries()) {
    try {
      await session.browser.close();
      console.log(`âœ… ì„¸ì…˜ ì¢…ë£Œ: ${sessionId}`);
    } catch (error) {
      console.error(`âŒ ì„¸ì…˜ ì¢…ë£Œ ì‹¤íŒ¨ ${sessionId}:`, error.message);
    }
  }
  
  // ëª¨ë“  ë®¤í…ìŠ¤ ì •ë¦¬
  sessionMutexes.clear();
  console.log('ğŸ§¹ ëª¨ë“  ë®¤í…ìŠ¤ ì •ë¦¬ ì™„ë£Œ');
  
  console.log('ğŸ‘‹ ì„œë²„ ì¢…ë£Œ ì™„ë£Œ');
  process.exit(0);
});
